import { openai } from '@ai-sdk/openai'
import { streamText } from 'ai'
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

// Allow up to 60 seconds for execution (DB fetch + AI generation)
export const maxDuration = 60

export async function POST(req: Request) {
  const { messages } = await req.json()
  
  // We only care about the LAST message the user typed. 
  // The "History" comes from the Database, not the Client.
  const latestMessage = messages[messages.length - 1]

  // 1. Setup Supabase Server Client
  const cookieStore = await cookies()
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) { return cookieStore.get(name)?.value },
        set(name: string, value: string, options: CookieOptions) { 
          try { cookieStore.set({ name, value, ...options }) } catch {} 
        },
        remove(name: string, options: CookieOptions) { 
          try { cookieStore.delete({ name, ...options }) } catch {} 
        },
      },
    }
  )

  // 2. Authentication & History Fetching
  let systemContext = "You are a helpful AI assistant."
  let userId = null

  try {
    // Get User Session
    const { data: { session } } = await supabase.auth.getSession()
    
    if (session) {
      userId = session.user.id
      
      // Fetch last 20 messages from DB (The "Memory")
      const { data: dbHistory } = await supabase
        .from('messages')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false }) // Get latest first
        .limit(20)

      // Create a "Summary" of the conversation for the AI
      if (dbHistory && dbHistory.length > 0) {
        // Reverse to put them in chronological order (Oldest -> Newest)
        const conversationLog = dbHistory.reverse().map((m: any) => 
          `${m.role === 'user' ? 'User' : 'AI Agent'}: ${m.content}`
        ).join('\n')

        systemContext += `\n\nCONTEXT / MEMORY:\nHere is the recent conversation history with this user:\n---\n${conversationLog}\n---\nUse this context to provide smarter answers.`
      }
    }
  } catch (error) {
    console.error("Supabase is likely down or unreachable:", error)
    // We silently fail here so the chat still works (just without memory)
  }

  // 3. Process the NEW User Message (Handle Images)
  let userContent: any = latestMessage.content
  if (typeof userContent === 'string' && userContent.includes('[Image:')) {
      const parts = userContent.split('[Image:')
      const text = parts[0].trim()
      const imageUrl = parts[1].replace(']', '').trim()
      
      userContent = [
        { type: 'text', text: text || 'Analyze this image' },
        { type: 'image', image: new URL(imageUrl) }
      ]
  }

  // 4. Generate AI Response
  const result = await streamText({
    model: openai('gpt-4o'),
    system: systemContext, // Inject the DB history here
    messages: [
      { role: 'user', content: userContent }
    ],
    // 5. Save the AI's response to the DB automatically
    onFinish: async (completion) => {
      if (userId) {
        try {
          await supabase.from('messages').insert({
            user_id: userId,
            role: 'assistant',
            content: completion.text,
            // created_at is auto-generated by Supabase
          })
        } catch (e) {
          console.error("Failed to save AI response:", e)
        }
      }
    }
  })

  return result.toTextStreamResponse()
}